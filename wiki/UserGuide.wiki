#summary User Guide
#labels Featured

This page mainly presents the abstract `AnalysisEngine` class.

Without an implementation, the class cannot work. There are several ways of using it. They depends on the extension points, in other words, the methods which are extended. The package comes with an example of descriptor, which should also be extended to be used.

== Parameters ==


  * `InputView` List of view names to process 
  * `ContextAnnotation` List of annotation names which delimits the text areas or the covered annotations to process
  * `InputAnnotation`	Ordered list of annotation names to consider as the Feature Structure index to process 
  * `InputFeature`  Feature name of the annotations whose string value will be processed
  * `OutputView` View name to consider as the view to receive the result; to be created whether `OutputAnnotation` is empty or simply to edit if `OutputAnnotation` is defined
  * `OutputAnnotation` Name of the annotation to create as the analysis result
  * `OutputFeature` Feature name of the annotation whose string value will contain the analysis result
	

== Constraints ==

  * `InputView` a pour valeur par défaut `_InitialView` 
  * 1 ou n `InputView` on traite les vues les unes après les autres 

  * `OutputView` a pour valeur par défaut la valeur de l'`InputView`
  * 1 seule possible

  * `ContextAnnotation` a pour valeur par défaut `uima.tcas.DocumentAnnotation` 
  * 1 ou n `ContextAnnotation` on traite un FSIndex de `ContextAnnotation` les unes après les autres 

  * `InputAnnotation` n'a pas de valeur par défaut
  * 0 `InputAnnotation` on traite la zone de texte couverte par les `ContextAnnotation`
  * 1 ou n `InputAnnotation` on traite un FSIndex de `InputAnnotation` soit chaque `InputAnnotation` les unes après les autres soit comme un tout ou autre si on étend la méthode processInputAnnotation 


  * Si `InputAnnotation` ou `InputFeature` est défini, alors les deux doivent l'être 
  * Si `OutputAnnotation` ou `OutputFeature` est défini, alors les deux doivent l'être 

  * Si `OutputAnnotation` existe alors on éditera seulement l'`OutputView` pour y rajouter des annotations sinon on créera l'`OutputView` spécifiée


(ne pas tenir compte des codes (`x`))
  * (4) Si `OutputAnnotation` == null alors `OutputView` est à créer ; si `OutputView` n'existe pas alors on la crée PASS ; sinon si existe FAIL
  * (1) Si `OutputView` == default i.e. `InputView` donc FAIL car existe déjà lorsqu'on tente de créer

  * (5) Si `OutputAnnotation` != null alors `OutputView` est à éditer ; si `OutputView` est non existante alors FAIL ; si existante alors PASS mais offsets des annotations créées peuvent déborder de la vue
  * (2) Si `OutputView` == default i.e. `InputView` donc PASS sans débordement d'annotations

  * n `OutputAnnotation`
  * (3) idem que (5,2) ; ALERT crée n annotation avec même value ; doute sur intérêt donc non implémentée
  * (6) idem que (3)

  * n `OutputView`
  * (7) idem que (4) ; ALERT crée n vues avec le même contenu ; doute sur intérêt donc non implémentée

  * n `OutputView` et n `OutputAnnotation`
  * (8) idem que (5) ; ALERT créé une même annotation sur plusieurs vues existantes distinctes ; doute sur intérêt donc non implémentée
  * (9) idem que (6)

== Methods ==

*`initialize` Method *
  * Getting the list of `InputView` name, `ContextAnnotation` type name, `InputAnnotation` type name, `OutputView` name, `OutputAnnotation` type name

*`process` Method *
*`` Method *
*`` Method *
*`` Method *

== Algorithm ==

== Descriptors ==

The current package also contains a descriptor example. This cannot be used as it. The name of the java class file should be changed to point the class which extends the AnalysisEngine class. New parameters can be added as well as type systems and capabilities...